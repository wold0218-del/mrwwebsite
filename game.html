<!DOCTYPE html>
<html>
<head>
   <title>Matching Game</title>
   <link rel="stylesheet" href="CSS/styles.css">
   <style>
        body {
            font-family: 'Poppins', Arial, sans-serif;
            text-align: center;
        }

        #game-board {
            width: 600px;
            margin: 20px auto;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        /* Card styling: front side = white & pink stripes; back (flipped) will be colored via --card-color */
        .card {
            width: 130px;
            height: 130px;
            /* white and soft-pink diagonal stripes for the card front */
            background: repeating-linear-gradient(45deg, #ffffff 0 12px, rgba(242,166,207,0.22) 12px 24px);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(0,0,0,0.06);
        }

        /* Make images blend with the card background so black/gray lines look colored in */
            .card img {
                width: 88%;
                height: 88%;
                display: none;
                border-radius: 8px;
                mix-blend-mode: multiply;
                /* make the linework solid and keep outlines dark while still allowing color fills */
                filter: grayscale(1) contrast(1.8) brightness(0.95) saturate(1.05) drop-shadow(0 0 0.6px rgba(0,0,0,0.9));
                object-fit: contain;
                background: transparent;
                position: relative;
                z-index: 2;
            }

        .flipped img {
            display: block;
        }

        /* When flipped: use the card color but make the drawing itself display normally
           (no multiply) with stronger contrast and a subtle drop-shadow so outlines stay
           crisp and the subject is easy to identify. Also add a thin border for separation. */
                .card.flipped {
                    background: var(--card-color, rgba(242,166,207,0.18));
                    border: 1px solid rgba(0,0,0,0.10);
                }

                .card.flipped img {
                    /* Show the original image colors/lines clearly on top of the background */
                    mix-blend-mode: normal;
                    filter: contrast(1.45) saturate(1.2) brightness(1);
                    /* add a subtle dark outline so thin strokes stand out on pastel backgrounds */
                    -webkit-filter: drop-shadow(0 1px 0 rgba(0,0,0,0.6));
                    filter: contrast(1.45) saturate(1.2) brightness(1) drop-shadow(0 1px 0 rgba(0,0,0,0.6));
                    transform: translateZ(0);
                    z-index: 2;
                }

        #message {
            font-size: 1.3rem;
            margin-top: 15px;
            font-weight: bold;
        }
   </style>
</head>

<body>
   <!-- Background Music (Hidden Autoplay) -->
   <audio id="bg-music" autoplay loop style="display: none;">
       <source src="videos/backgroundmusic.wav" type="audio/wav">
       <source src="videos/backgroundmusic.wav" type="audio/mpeg">
       Your browser does not support the audio element.
   </audio>
   
   <nav>
       <ul>
           <li><a href="index.html">Home</a></li>
           <li><a href="hobbies.html">Hobbies</a></li>
           <li><a href="discover.html">Discover UMD</a></li>
           <li><a href="resume.html">Resume</a></li>
           <li><a href="career.html">Career</a></li>
           <li><a href="game.html">Game</a></li>
       </ul>
   </nav>

   <h1>Game Time!</h1>
   <p>Match all the drawings!</p>


   <div id="game-board"></div>
   <p id="message"></p>

   <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Game Image Test</title>
</head>
<body>
    <h1>Game Image Test</h1>

    <!-- This is where the image will appear -->
    <img id="gameImage" alt="game image">

    <!-- Put the script AFTER the img -->
    <script>
        const images = [
            "images/UMDbook3.png",
            "images/bulldog2.png",
            "images/gradhat2.png",
            "images/lakesuperior2.png",
            "images/liftbridge2.png",
            "images/squirrel2.png",
            "images/ship2.png",
            "images/trees2.png"
        ];

        let currentIndex = 0;
        const imgEl = document.getElementById("gameImage");

        // show the first image
        imgEl.src = images[currentIndex];
    </script>
</body>
</html>


        // Duplicate to create pairs
        const cardImages = [...images, ...images];

        // Shuffle function
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        shuffle(cardImages);

        const gameBoard = document.getElementById("game-board");
        let flippedCards = [];
        let matchedPairs = 0;

        // Assign a pastel color per unique image (keeps consistent pairs the same color)
        const palette = ['#f2a6cf','#b7abff','#9be0ec','#ffd1a6','#c6f7d9','#ffd1e6','#e6d1ff','#c3e8ff'];
        const colorMap = {};
        images.forEach((name, i) => {
            colorMap[name] = palette[i % palette.length];
        });

        // Create cards
        // helper: create an outlined version of an image using edge detection (Sobel) and a thicker drawn outline
        function makeOutlinedDataURL(src, thickness = 3) {
            return new Promise((resolve) => {
                const source = new Image();
                source.crossOrigin = 'anonymous';
                source.onload = () => {
                    const w = source.naturalWidth;
                    const h = source.naturalHeight;

                    // draw source to a canvas
                    const srcCanvas = document.createElement('canvas');
                    srcCanvas.width = w;
                    srcCanvas.height = h;
                    const sctx = srcCanvas.getContext('2d');
                    sctx.drawImage(source, 0, 0, w, h);
                    const srcData = sctx.getImageData(0,0,w,h);

                    // grayscale
                    const gray = new Float32Array(w*h);
                    for (let i=0;i<w*h;i++){
                        const si = i*4;
                        const r = srcData.data[si];
                        const g = srcData.data[si+1];
                        const b = srcData.data[si+2];
                        const a = srcData.data[si+3];
                        // if transparent, mark as white
                        if (a < 20) { gray[i] = 255; continue; }
                        gray[i] = 0.299*r + 0.587*g + 0.114*b;
                    }

                    // sobel
                    const gx = new Float32Array(w*h);
                    const gy = new Float32Array(w*h);
                    for (let y=1;y<h-1;y++){
                        for (let x=1;x<w-1;x++){
                            const i = y*w + x;
                            const v00 = gray[(y-1)*w + (x-1)];
                            const v01 = gray[(y-1)*w + (x)];
                            const v02 = gray[(y-1)*w + (x+1)];
                            const v10 = gray[(y)*w + (x-1)];
                            const v11 = gray[(y)*w + (x)];
                            const v12 = gray[(y)*w + (x+1)];
                            const v20 = gray[(y+1)*w + (x-1)];
                            const v21 = gray[(y+1)*w + (x)];
                            const v22 = gray[(y+1)*w + (x+1)];
                            gx[i] = ( -v00 + v02 -2*v10 +2*v12 -v20 + v22 );
                            gy[i] = ( -v00 -2*v01 -v02 + v20 +2*v21 + v22 );
                        }
                    }

                    // magnitude and threshold to create edge mask
                    const mag = new Float32Array(w*h);
                    let max = 0;
                    for (let i=0;i<w*h;i++){
                        mag[i] = Math.hypot(gx[i], gy[i]);
                        if (mag[i] > max) max = mag[i];
                    }
                    const thresh = Math.max(20, max * 0.15);

                    // output canvas larger to accommodate outline
                    const outW = w + 2*thickness;
                    const outH = h + 2*thickness;
                    const outCanvas = document.createElement('canvas');
                    outCanvas.width = outW;
                    outCanvas.height = outH;
                    const octx = outCanvas.getContext('2d');

                    // paint black outline by drawing circles at edge pixels (creates thicker, rounded strokes)
                    octx.fillStyle = 'black';
                    octx.imageSmoothingEnabled = true;
                    for (let y=0;y<h;y++){
                        for (let x=0;x<w;x++){
                            const i = y*w + x;
                            if (mag[i] >= thresh) {
                                octx.beginPath();
                                octx.arc(x + thickness, y + thickness, thickness, 0, Math.PI*2);
                                octx.fill();
                            }
                        }
                    }

                    // draw original image on top, offset by thickness
                    octx.drawImage(source, thickness, thickness, w, h);

                    resolve(outCanvas.toDataURL());
                };
                source.onerror = () => resolve(src);
                source.src = src;
            });
        }

        // Build the game board with configurable outline options
        async function buildBoard(thickness = 3, sensitivityPercent = 15) {
            gameBoard.innerHTML = '';
            flippedCards = [];
            matchedPairs = 0;
            document.getElementById('message').textContent = '';

            const sensitivity = Math.max(0.01, sensitivityPercent / 100);

            for (const src of cardImages) {
                const card = document.createElement("div");
                card.classList.add("card");

                // set the card color variable (used by .card.flipped)
                const color = colorMap[src] || palette[0];
                card.style.setProperty('--card-color', color);

                const img = document.createElement("img");
                img.alt = src.replace(/\.[^/.]+$/, '');

                // Prefer a preprocessed outlined file if present (images/outlined/<name>),
                // otherwise fall back to client-side outlining using current settings.
                const originalSrc = "images/" + src;
                const outlinedPath = "images/outlined/" + src;
                img.src = outlinedPath;
                img.onerror = async () => {
                    try {
                        const outlinedDataUrl = await makeOutlinedDataURL(originalSrc, thickness, sensitivity);
                        img.src = outlinedDataUrl;
                    } catch (e) {
                        img.src = originalSrc;
                    }
                };

                card.appendChild(img);

                card.addEventListener("click", () => {
                    if (card.classList.contains("flipped") || flippedCards.length === 2) return;

                    card.classList.add("flipped");
                    flippedCards.push(card);

                    if (flippedCards.length === 2) {
                        checkMatch();
                    }
                });

                gameBoard.appendChild(card);
            }
        }

        // initial build with default settings
        buildBoard(3, 15);

        function checkMatch() {
            const [card1, card2] = flippedCards;
            const img1 = card1.querySelector("img").src;
            const img2 = card2.querySelector("img").src;

            if (img1 === img2) {
                matchedPairs++;
                flippedCards = [];

                if (matchedPairs === images.length) {
                    document.getElementById("message").textContent =
                        "ðŸŽ‰ You matched all pairs!";
                }
            } else {
                setTimeout(() => {
                    card1.classList.remove("flipped");
                    card2.classList.remove("flipped");
                    flippedCards = [];
                }, 800);
            }
        }


   </script>

</body>
</html>
