<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Matching Game</title>
    <link rel="stylesheet" href="CSS/styles.css">
    <style>
        body {
            font-family: 'Poppins', Arial, sans-serif;
            text-align: center;
        }

        #game-board {
            width: 600px;
            margin: 20px auto;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        /* Card styling: front side = white & pink stripes; back (flipped) will be colored via --card-color */
        .card {
            width: 130px;
            height: 130px;
            background: repeating-linear-gradient(
                45deg,
                #ffffff 0 12px,
                rgba(242,166,207,0.22) 12px 24px
            );
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(0,0,0,0.06);
        }

        .card img {
            width: 88%;
            height: 88%;
            display: none;
            border-radius: 8px;
            mix-blend-mode: multiply;
            filter: grayscale(1) contrast(1.8) brightness(0.95) saturate(1.05)
                    drop-shadow(0 0 0.6px rgba(0,0,0,0.9));
            object-fit: contain;
            background: transparent;
            position: relative;
            z-index: 2;
        }

        .card.flipped {
            background: var(--card-color, rgba(242,166,207,0.18));
            border: 1px solid rgba(0,0,0,0.10);
        }

        .card.flipped img {
            mix-blend-mode: normal;
            filter: contrast(1.45) saturate(1.2) brightness(1)
                    drop-shadow(0 1px 0 rgba(0,0,0,0.6));
            transform: translateZ(0);
            z-index: 2;
        }

        #message {
            font-size: 1.3rem;
            margin-top: 15px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <!-- Background Music (Hidden Autoplay) -->
    <audio id="bg-music" autoplay loop style="display: none;">
        <source src="videos/backgroundmusic.wav" type="audio/wav">
        <source src="videos/backgroundmusic.wav" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <nav>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="hobbies.html">Hobbies</a></li>
            <li><a href="discover.html">Discover UMD</a></li>
            <li><a href="resume.html">Resume</a></li>
            <li><a href="career.html">Career</a></li>
            <li><a href="game.html">Game</a></li>
        </ul>
    </nav>

    <h1>Game Time!</h1>
    <p>Match all the drawings!</p>

    <div id="game-board"></div>
    <p id="message"></p>

    <!-- All your game JavaScript lives in this single script tag -->
    <script>
        // Just the filenames â€“ the script will prepend "images/" itself
        const images = [
            "UMDbook3.png",
            "bulldog2.png",
            "gradhat2.png",
            "lakesuperior2.png",
            "liftbridge2.png",
            "squirrel2.png",
            "ship2.png",
            "trees2.png"
        ];

        // Duplicate to create pairs
        const cardImages = [...images, ...images];

        // Shuffle function
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        shuffle(cardImages);

        const gameBoard = document.getElementById("game-board");
        let flippedCards = [];
        let matchedPairs = 0;

        // Assign a pastel color per unique image (keeps consistent pairs the same color)
        const palette = [
            '#f2a6cf','#b7abff','#9be0ec','#ffd1a6',
            '#c6f7d9','#ffd1e6','#e6d1ff','#c3e8ff'
        ];

        const colorMap = {};
        images.forEach((name, i) => {
            colorMap[name] = palette[i % palette.length];
        });

        // helper: create an outlined version of an image using edge detection (Sobel)
        function makeOutlinedDataURL(src, thickness = 3) {
            return new Promise((resolve) => {
                const source = new Image();
                source.crossOrigin = 'anonymous';

                source.onload = () => {
                    const w = source.naturalWidth;
                    const h = source.naturalHeight;

                    const srcCanvas = document.createElement('canvas');
                    srcCanvas.width = w;
                    srcCanvas.height = h;
                    const sctx = srcCanvas.getContext('2d');
                    sctx.drawImage(source, 0, 0, w, h);
                    const srcData = sctx.getImageData(0,0,w,h);

                    const gray = new Float32Array(w*h);
                    for (let i=0;i<w*h;i++){
                        const si = i*4;
                        const r = srcData.data[si];
                        const g = srcData.data[si+1];
                        const b = srcData.data[si+2];
                        const a = srcData.data[si+3];
                        if (a < 20) { gray[i] = 255; continue; }
                        gray[i] = 0.299*r + 0.587*g + 0.114*b;
                    }

                    const gx = new Float32Array(w*h);
                    const gy = new Float32Array(w*h);

                    for (let y=1;y<h-1;y++){
                        for (let x=1;x<w-1;x++){
                            const i = y*w + x;
                            const v00 = gray[(y-1)*w + (x-1)];
                            const v01 = gray[(y-1)*w + (x)];
                            const v02 = gray[(y-1)*w + (x+1)];
                            const v10 = gray[(y)*w + (x-1)];
                            const v11 = gray[(y)*w + (x)];
                            const v12 = gray[(y)*w + (x+1)];
                            const v20 = gray[(y+1)*w + (x-1)];
                            const v21 = gray[(y+1)*w + (x)];
                            const v22 = gray[(y+1)*w + (x+1)];
                            gx[i] = ( -v00 + v02 -2*v10 +2*v12 -v20 + v22 );
                            gy[i] = ( -v00 -2*v01 -v02 + v20 +2*v21 + v22 );
                        }
                    }

                    const mag = new Float32Array(w*h);
                    let max = 0;
                    for (let i=0;i<w*h;i++){
                        mag[i] = Math.hypot(gx[i], gy[i]);
                        if (mag[i] > max) max = mag[i];
                    }
                    const thresh = Math.max(20, max * 0.15);

                    const outW = w + 2*thickness;
                    const outH = h + 2*thickness;
                    const outCanvas = document.createElement('canvas');
                    outCanvas.width = outW;
                    outCanvas.height = outH;
                    const octx = outCanvas.getContext('2d');

                    octx.fillStyle = 'black';
                    octx.imageSmoothingEnabled = true;
                    for (let y=0;y<h;y++){
                        for (let x=0;x<w;x++){
                            const i = y*w + x;
                            if (mag[i] >= thresh) {
                                octx.beginPath();
                                octx.arc(x + thickness, y + thickness, thickness, 0, Math.PI*2);
                                octx.fill();
                            }
                        }
                    }

                    octx.drawImage(source, thickness, thickness, w, h);
                    resolve(outCanvas.toDataURL());
                };

                source.onerror = () => resolve(src);
                source.src = src;
            });
        }

        // Build the game board
        async function buildBoard(thickness = 3, sensitivityPercent = 15) {
            gameBoard.innerHTML = '';
            flippedCards = [];
            matchedPairs = 0;
            document.getElementById('message').textContent = '';

            const sensitivity = Math.max(0.01, sensitivityPercent / 100);

            for (const src of cardImages) {
                const card = document.createElement("div");
                card.classList.add("card");

                const color = colorMap[src] || palette[0];
                card.style.setProperty('--card-color', color);

                const img = document.createElement("img");
                img.alt = src.replace(/\.[^/.]+$/, '');

                const originalSrc = "images/" + src;
                const outlinedPath = "images/outlined/" + src;

                img.src = outlinedPath;
                img.onerror = async () => {
                    try {
                        const outlinedDataUrl = await makeOutlinedDataURL(originalSrc, thickness, sensitivity);
                        img.src = outlinedDataUrl;
                    } catch (e) {
                        img.src = originalSrc;
                    }
                };

                card.appendChild(img);

                card.addEventListener("click", () => {
                    if (card.classList.contains("flipped") || flippedCards.length === 2) return;

                    card.classList.add("flipped");
                    flippedCards.push(card);

                    if (flippedCards.length === 2) {
                        checkMatch();
                    }
                });

                gameBoard.appendChild(card);
            }
        }

        buildBoard(3, 15);

        function checkMatch() {
            const [card1, card2] = flippedCards;
            const img1 = card1.querySelector("img").src;
            const img2 = card2.querySelector("img").src;

            if (img1 === img2) {
                matchedPairs++;
                flippedCards = [];

                if (matchedPairs === images.length) {
                    document.getElementById("message").textContent =
                        "ðŸŽ‰ You matched all pairs!";
                }
            } else {
                setTimeout(() => {
                    card1.classList.remove("flipped");
                    card2.classList.remove("flipped");
                    flippedCards = [];
                }, 800);
            }
        }
    </script>
</body>
</html>
